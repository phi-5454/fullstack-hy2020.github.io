---
mainImage: ../../../images/part-0.svg
part: 0
letter: b
lang: fr
---

<div class="content">

Avant de commencer la programmation, nous passerons en revue certains principes de dÃ©veloppement Web en examinant un exemple d'application sur <https://studies.cs.helsinki.fi/exampleapp>.

L'application n'existe que pour dÃ©montrer certains concepts de base du cours et n'est en aucun cas un exemple de <i>comment</i> une application Web moderne doit Ãªtre crÃ©Ã©e.
Au contraire, il dÃ©montre certaines anciennes techniques de dÃ©veloppement Web, qui pourraient mÃªme Ãªtre considÃ©rÃ©es comme de <i>mauvaises pratiques</i> de nos jours.

Le code sera conforme aux meilleures pratiques actuelles Ã  partir de la [partieÂ 1](/fr/part1).

Ouvrez l'[exemple d'application](https://studies.cs.helsinki.fi/exampleapp) dans votre navigateur. Parfois, cela prend un certain temps.

**La 1Ã¨re rÃ¨gle du dÃ©veloppement Web**Â : gardez toujours la Developer Console ouverte sur votre navigateur Web. Sur macOS, ouvrez la console en appuyant simultanÃ©ment sur _F12_ ou _option-cmd-i_. Sous Windows ou Linux, ouvrez la console en appuyant simultanÃ©ment sur _F12_ ou _ctrl-shift-i_. La console peut Ã©galement Ãªtre ouverte via le [menu contextuel](https://en.wikipedia.org/wiki/Menu_key).

N'oubliez pas de <i>toujours</i> garder la Developer Console ouverte lors du dÃ©veloppement d'applications Web.

La console ressemble Ã  ceci :

![Une capture d'Ã©cran des outils de dÃ©veloppement ouverts dans un navigateur](../../images/0/1e.png)

Assurez-vous que l'onglet <i>RÃ©seau</i> est ouvert et cochez l'option <i>DÃ©sactiver le cache</i> comme indiquÃ©. <i>Conserver le journal</i> peut Ã©galement Ãªtre utileÂ : il enregistre les journaux imprimÃ©s par l'application lorsque la page est rechargÃ©e.

**NBÂ :** L'onglet le plus important est l'onglet <i>Console</i>. Cependant, dans cette introduction, nous utiliserons un peu l'onglet <i>RÃ©seau</i>.

### HTTP GET

Le serveur et le navigateur Web communiquent entre eux Ã  l'aide du protocole [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP). L'onglet <i>RÃ©seau</i> montre comment le navigateur et le serveur communiquent.

Lorsque vous rechargez la page (appuyez sur la touche F5 ou sur le symboleÂ &#8635; de votre navigateur), la console indique que deux Ã©vÃ©nements se sont produitsÂ :

- Le navigateur a rÃ©cupÃ©rÃ© le contenu de la page <i>studies.cs.helsinki.fi/exampleapp</i> du serveur
- Et a tÃ©lÃ©chargÃ© l'image <i>kuva.png</i>

![Capture d'Ã©cran de la console dÃ©veloppeur montrant ces deux Ã©vÃ©nements](../../images/0/2e.png)

Sur un petit Ã©cran, vous devrez peut-Ãªtre Ã©largir la fenÃªtre de la console pour les voir.

Cliquer sur le premier Ã©vÃ©nement rÃ©vÃ¨le plus d'informations sur ce qui se passeÂ :

![Vue dÃ©taillÃ©e d'un seul Ã©vÃ©nement](../../images/0/3e.png)

La partie supÃ©rieure, <i>GÃ©nÃ©ral</i>, montre que le navigateur a fait une requÃªte Ã  l'adresse <i>https://studies.cs.helsinki.fi/exampleapp</i> (bien que l'adresse ait lÃ©gÃ¨rement changÃ© depuis que cette photo a Ã©tÃ© prise) en utilisant la mÃ©thode [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET), et que la requÃªte a rÃ©ussi, car la rÃ©ponse du serveur avait le [code de statut](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) 200.

La requÃªte et la rÃ©ponse du serveur ont plusieurs [en-tÃªtes](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)Â :

![](../../images/0/4e.png)


Les <i>en-tÃªtes de rÃ©ponse</i> en haut nous indiquent par ex. la taille de la rÃ©ponse en octets et l'heure exacte de la rÃ©ponse. Un en-tÃªte important [Content-Type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) nous indique que la rÃ©ponse est un fichier texte en [utf-8](https://en.wikipedia.org/wiki/UTF-8)-format, dont le contenu a Ã©tÃ© formatÃ© avec HTML. De cette faÃ§on, le navigateur sait que la rÃ©ponse est une page [HTML](https://en.wikipedia.org/wiki/HTML) normale et la restitue au navigateur "comme une page Web".

L'onglet <i>RÃ©ponse</i> affiche les donnÃ©es de rÃ©ponse, une page HTML normale. La section <i>body</i> dÃ©termine la structure de la page rendue Ã  l'Ã©cranÂ :

![Capture d'Ã©cran de l'onglet rÃ©ponse](../../images/0/5e.png)

La page contient un Ã©lÃ©ment [div](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div), qui Ã  son tour contient un titre, un lien vers la page <i>notes </i> et une balise [img](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img) et affiche le nombre de notes crÃ©Ã©es.

En raison de la balise img, le navigateur effectue une seconde <i>requÃªte HTTP</i> pour rÃ©cupÃ©rer l'image <i>kuva.png</i> du serveur. Les dÃ©tails de la demande sont les suivants :

![Vue dÃ©taillÃ©e du deuxiÃ¨me Ã©vÃ©nement](../../images/0/6e.png)

La requÃªte a Ã©tÃ© faite Ã  l'adresse <https://studies.cs.helsinki.fi/exampleapp/kuva.png> et son type est HTTP GET. Les en-tÃªtes de rÃ©ponse nous indiquent que la taille de la rÃ©ponse est de 89350 octets et que son [Content-type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) est <i >image/png</i>, c'est donc une image png. Le navigateur utilise ces informations pour restituer correctement l'image Ã  l'Ã©cran.

La chaÃ®ne d'Ã©vÃ©nements provoquÃ©e par l'ouverture de la page https://studies.cs.helsinki.fi/exampleapp sur un navigateur se prÃ©sente comme suit [diagramme de sÃ©quence](https://www.geeksforgeeks.org/unified-modeling-language-uml-sÃ©quence-diagrammes/):

![SchÃ©ma de sÃ©quence du flux traitÃ© ci-dessus](../../images/0/7e.png)

Tout d'abord, le navigateur envoie une requÃªte HTTP GET au serveur pour rÃ©cupÃ©rer le code HTML de la page. La balise <i>img</i> dans le code HTML invite le navigateur Ã  rÃ©cupÃ©rer l'image <i>kuva.png</i>. Le navigateur affiche la page HTML et l'image Ã  l'Ã©cran.

MÃªme s'il est difficile de s'en apercevoir, la page HTML commence Ã  s'afficher avant que l'image n'ait Ã©tÃ© extraite du serveur.

### Applications Web traditionnelles

La page d'accueil de l'exemple d'application fonctionne comme une <i>application Web traditionnelle</i>. En entrant dans la page, le navigateur va chercher sur le serveur le document HTML dÃ©taillant la structure et le contenu textuel de la page.

Le serveur a formÃ© ce document d'une maniÃ¨re ou d'une autre. Le document peut Ãªtre un fichier texte <i>statique</i> enregistrÃ© dans le rÃ©pertoire du serveur. Le serveur peut Ã©galement former les documents HTML de maniÃ¨re <i>dynamique</i> selon le code de l'application, en utilisant par exemple les donnÃ©es d'une base de donnÃ©es.
Le code HTML de l'exemple d'application a Ã©tÃ© formÃ© dynamiquement, car il contient des informations sur le nombre de notes crÃ©Ã©es.

Le code HTML de la page d'accueil est le suivant :

```js
const getFrontPageHtml = (noteCount) => {
  return(`
    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <div class='container'>
          <h1>Full stack example app</h1>
          <p>number of notes created ${noteCount}</p>
          <a href='/notes'>notes</a>
          <img src='kuva.png' width='200' />
        </div>
      </body>
    </html>
`)
} 

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})
```
Vous n'avez pas encore besoin de comprendre le code.

Le contenu de la page HTML a Ã©tÃ© enregistrÃ© en tant que chaÃ®ne de modÃ¨le, ou une chaÃ®ne qui permet d'Ã©valuer, par exemple, des variables au milieu de celle-ci. La partie dynamique de la page d'accueil, le nombre de notes enregistrÃ©es (dans le code <em>noteCount</em>), est remplacÃ©e par le nombre actuel de notes (dans le code <em>notes.length</em>) dans la chaÃ®ne de modÃ¨le.

Ã‰crire du HTML au milieu du code n'est bien sÃ»r pas intelligent, mais pour les programmeurs PHP de la vieille Ã©cole, c'Ã©tait une pratique normale.

Dans les applications Web traditionnelles, le navigateur est "stupide". Il rÃ©cupÃ¨re uniquement les donnÃ©es HTML du serveur et toute la logique d'application se trouve sur le serveur. Un serveur peut Ãªtre crÃ©Ã© en utilisant Java Spring (comme dans le cours de l'UniversitÃ© d'Helsinki [Web-palvelinohjelmointi](https://courses.helsinki.fi/fi/tkt21007/119558639)), Python Flask (comme dans le cours [tietokantasovellus](https://materiaalit.github.io/tsoha-18/)) ou avec [Ruby on Rails](http://rubyonrails.org/) pour ne citer que quelques exemples.

L'exemple utilise [Express](https://expressjs.com/) de Node.js.
Ce cours utilisera Node.js et Express pour crÃ©er des serveurs Web.

### ExÃ©cution de la logique d'application dans le navigateur

Gardez la Developer Console ouverte. Videz la console en cliquant sur le symbole ğŸš« ou en tapant clear() dans la console.
DÃ©sormais, lorsque vous accÃ©dez Ã  la page [notes](https://studies.cs.helsinki.fi/exampleapp/notes), le navigateur effectue 4Â requÃªtes HTTPÂ :

![Capture d'Ã©cran de la console dÃ©veloppeur avec les 4 requÃªtes visibles](../../images/0/8e.png)

Toutes les demandes ont des types <i>diffÃ©rents</i>. Le type de la premiÃ¨re requÃªte est <i>document</i>. C'est le code HTML de la page, et il se prÃ©sente comme suitÂ :

![Vue dÃ©taillÃ©e de la premiÃ¨re requÃªte](../../images/0/9e.png)

Lorsque l'on compare la page affichÃ©e sur le navigateur et le code HTML renvoyÃ© par le serveur, on remarque que le code ne contient pas la liste des notes.
La section [head](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head) du code HTML contient un [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script)-tag, qui amÃ¨ne le navigateur Ã  rÃ©cupÃ©rer un fichier JavaScript appelÃ© <i>main.js</i>.

Le code JavaScript ressemble Ã  ceciÂ :

```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText)
    console.log(data)

    var ul = document.createElement('ul')
    ul.setAttribute('class', 'notes')

    data.forEach(function(note) {
      var li = document.createElement('li')

      ul.appendChild(li)
      li.appendChild(document.createTextNode(note.content))
    })

    document.getElementById('notes').appendChild(ul)
  }
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```
Les dÃ©tails du code ne sont pas importants pour le moment, mais du code a Ã©tÃ© inclus pour pimenter les images et le texte. Nous commencerons correctement Ã  coder dans la [partieÂ 1](/fr/part1). L'exemple de code de cette partie n'est en fait pas du tout pertinent pour les techniques de codage de ce cours.

> Certains pourraient se demander pourquoi xhttp-object est utilisÃ© Ã  la place du fetch moderne. Cela est dÃ» au fait de ne pas encore du tout vouloir entrer dans les promesses, et le code ayant un rÃ´le secondaire dans cette partie. Nous reviendrons sur les moyens modernes de faire des requÃªtes au serveur dans la partie 2.

ImmÃ©diatement aprÃ¨s avoir rÃ©cupÃ©rÃ© la balise <i>script</i>, le navigateur commence Ã  exÃ©cuter le code.

Les deux derniÃ¨res lignes indiquent au navigateur d'effectuer une requÃªte HTTP GET Ã  l'adresse du serveur <i>/data.json</i>Â :

```js
xhttp.open('GET', '/data.json', true)
xhttp.send()
```
Il s'agit de la requÃªte la plus basse affichÃ©e dans l'onglet RÃ©seau.

Nous pouvons essayer d'aller Ã  l'adresse <https://studies.cs.helsinki.fi/exampleapp/data.json> directement depuis le navigateurÂ :

![](../../images/0/10e.png)

On y retrouve les notes en [JSON](https://en.wikipedia.org/wiki/JSON) "raw data". Par dÃ©faut, les navigateurs basÃ©s sur Chromium ne sont pas trÃ¨s bons pour afficher les donnÃ©es JSON. Des plugins peuvent Ãªtre utilisÃ©s pour gÃ©rer le formatage. Installez, par exemple, [JSONVue](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) sur Chrome, et rechargez la page. Les donnÃ©es sont maintenant bien formatÃ©esÂ :

![Sortie JSON formatÃ©e](../../images/0/11e.png)

Ainsi, le code JavaScript de la page de notes ci-dessus tÃ©lÃ©charge les donnÃ©es JSON contenant les notes et forme une liste Ã  puces Ã  partir du contenu de la noteÂ :

Cela se fait par le code suivant :

```js
const data = JSON.parse(this.responseText)
console.log(data)

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})

document.getElementById('notes').appendChild(ul)
```
Le code crÃ©e d'abord une liste non ordonnÃ©e avec une balise [ul](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul)-tag...

```js
var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')
```
... puis ajoute une balise [li](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li) pour chaque note. Seul le champ <i>contenu</i> de chaque note devient le contenu de la balise li. Les horodatages trouvÃ©s dans les donnÃ©es brutes ne sont utilisÃ©s pour rien ici.

```js
data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```
Ouvrez maintenant l'onglet <i>Console</i> sur votre Developer ConsoleÂ :


![Capture d'Ã©cran de l'onglet console sur la console dÃ©veloppeur](../../images/0/12e.png)

En cliquant sur le petit triangle au dÃ©but de la ligne, vous pouvez dÃ©velopper le texte sur la console.

![Capture d'Ã©cran de l'une des entrÃ©es prÃ©cÃ©demment rÃ©duites dÃ©veloppÃ©e](../../images/0/13e.png)

Cette sortie sur la console est causÃ©e par la commande <em>console.log</em> dans le codeÂ :

```js
const data = JSON.parse(this.responseText)
console.log(data)
```

Ainsi, aprÃ¨s avoir reÃ§u les donnÃ©es du serveur, le code les imprime sur la console.

L'onglet <i>Console</i> et la commande <em>console.log</em> vous deviendront trÃ¨s familiers pendant le cours. 


### Gestionnaires d'Ã©vÃ©nements et fonctions Callback

La structure de ce code est un peu bizarre :


```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // code that takes care of the server response
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```
La requÃªte au serveur est envoyÃ©e sur la derniÃ¨re ligne, mais le code pour gÃ©rer la rÃ©ponse se trouve plus haut. Que se passe-t-il?

```js
xhttp.onreadystatechange = function () {
```

Sur cette ligne, un <i>gestionnaire d'Ã©vÃ©nements</i> pour l'Ã©vÃ©nement <i>onreadystatechange</i> est dÃ©fini pour l'objet <em>xhttp</em> effectuant la requÃªte. Lorsque l'Ã©tat de l'objet change, le navigateur appelle la fonction de gestionnaire d'Ã©vÃ©nements. Le code de la fonction vÃ©rifie que [readyState](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState) est Ã©gal Ã  4 (ce qui dÃ©crit la situation <i>L'opÃ©ration est terminÃ©e</i>) et que le code d'Ã©tat HTTP de la rÃ©ponse est 200.


```js
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // code that takes care of the server response
  }
}
```
Le mÃ©canisme d'appel des gestionnaires d'Ã©vÃ©nements est trÃ¨s courant en JavaScript. Les fonctions de gestionnaire d'Ã©vÃ©nements sont appelÃ©es fonctions [callback](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function). Le code d'application n'appelle pas les fonctions lui-mÃªme, mais l'environnement d'exÃ©cution - le navigateur, appelle la fonction Ã  un moment appropriÃ©, lorsque l'<i>Ã©vÃ©nement</i> s'est produit.

### Document Object Model ou DOM

Nous pouvons considÃ©rer les pages HTML comme des arborescences implicites.

<pre>
html
  head
    link
    script
  body
    div
      h1
      div
        ul
          li
          li
          li
      form
        input
        input
</pre>

La mÃªme structure arborescente peut Ãªtre vue sur l'onglet <i>Ã‰lÃ©ments</i> de la console.

![Une capture d'Ã©cran de l'onglet Ã‰lÃ©ments de la console dÃ©veloppeur](../../images/0/14e.png)

Le fonctionnement du navigateur est basÃ© sur l'idÃ©e de reprÃ©senter les Ã©lÃ©ments HTML sous forme d'arborescence.

Document Object Model, ou [DOM](https://en.wikipedia.org/wiki/Document_Object_Model), est une interface de programmation d'application (<i>API</i>) qui permet la modification par programmation des <i>arborescences d'Ã©lÃ©ments </i> correspondant aux pages Web.

Le code JavaScript introduit dans le chapitre prÃ©cÃ©dent utilisait l'API DOM pour ajouter une liste de notes Ã  la page.

Le code suivant crÃ©e un nouveau nÅ“ud pour la variable <em>ul</em> et y ajoute des nÅ“uds enfantsÂ :

```js
var ul = document.createElement('ul')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```
Enfin, la branche d'arborescence de la variable <em>ul</em> est connectÃ©e Ã  sa place dans l'arborescence HTML de toute la pageÂ :

```js
document.getElementById('notes').appendChild(ul)
```

### Manipulation de l'objet document depuis la console

Le nÅ“ud le plus haut de l'arborescence DOM d'un document HTML est appelÃ© l'objet <em>document</em>. Nous pouvons effectuer diverses opÃ©rations sur une page Web Ã  l'aide de l'API DOM. Vous pouvez accÃ©der Ã  l'objet <em>document</em> en tapant <em>document</em> dans l'onglet ConsoleÂ :

![](../../images/0/15e.png)

Ajoutons une nouvelle note Ã  la page depuis la console.

Tout d'abord, nous allons obtenir la liste des notes de la page. La liste se trouve dans le premier Ã©lÃ©ment ul de la pageÂ :

```js
list = document.getElementsByTagName('ul')[0]
```

CrÃ©ez ensuite un nouvel Ã©lÃ©ment li et ajoutez-y du contenu textuelÂ :

```js
newElement = document.createElement('li')
newElement.textContent = 'Page manipulation from console is easy'
```

Et ajoutez le nouvel Ã©lÃ©ment li Ã  la listeÂ :

```js
list.appendChild(newElement)
```

![Capture d'Ã©cran de la page avec la nouvelle note ajoutÃ©e Ã  la liste](../../images/0/16e.png)

MÃªme si la page est mise Ã  jour sur votre navigateur, les modifications ne sont pas permanentes. Si la page est rechargÃ©e, la nouvelle note disparaÃ®tra, car les modifications n'ont pas Ã©tÃ© transmises au serveur. Le code JavaScript que le navigateur rÃ©cupÃ¨re crÃ©era toujours la liste des notes basÃ©es sur les donnÃ©es JSON Ã  partir de l'adresse <https://studies.cs.helsinki.fi/exampleapp/data.json>.

### CSS

L'Ã©lÃ©ment <i>head</i> du code HTML de la page Notes contient une balise [link](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link), qui dÃ©termine que le navigateur doit rÃ©cupÃ©rer une feuille de style [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) Ã  partir de l'adresse [main.css](https://studies.cs.helsinki.fi/exampleapp/main.css).

Les feuilles de style en cascade, ou CSS, sont un langage de feuille de style utilisÃ© pour dÃ©terminer l'apparence des pages Web.

Le fichier CSS rÃ©cupÃ©rÃ© ressemble Ã  ceciÂ : 

```css
.container {
  padding: 10px;
  border: 1px solid; 
}

.notes {
  color: blue;
}
```
Le fichier dÃ©finit deux [sÃ©lecteurs de classe](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors). Ceux-ci sont utilisÃ©s pour sÃ©lectionner certaines parties de la page et pour dÃ©finir des rÃ¨gles de style pour les styliser.

Une dÃ©finition de sÃ©lecteur de classe commence toujours par un point et contient le nom de la classe.

Les classes sont des [attributs](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class), qui peuvent Ãªtre ajoutÃ©s aux Ã©lÃ©ments HTML.

Les attributs CSS peuvent Ãªtre examinÃ©s dans l'onglet <i>Ã©lÃ©ments</i> de la consoleÂ :

![Capture d'Ã©cran de l'onglet Ã‰lÃ©ments sur la console dÃ©veloppeur](../../images/0/17e.png)

L'Ã©lÃ©ment <i>div</i> le plus externe a la classe <i>container</i>. L'Ã©lÃ©ment <i>ul</i> contenant la liste des notes a la classe <i>notes</i>.

La rÃ¨gle CSS dÃ©finit que les Ã©lÃ©ments avec la classe <i>container</i> seront dÃ©limitÃ©s par une [bordure](https://developer.mozilla.org/en-US/docs/Web/CSS/border) large d'un pixel. Il dÃ©finit Ã©galement 10 pixels de [padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding) sur l'Ã©lÃ©ment. Cela ajoute un espace vide entre le contenu de l'Ã©lÃ©ment et la bordure.

La deuxiÃ¨me rÃ¨gle CSS dÃ©finit la couleur du texte des notes en bleu.

Les Ã©lÃ©ments HTML peuvent Ã©galement avoir d'autres attributs en dehors des classes. L'Ã©lÃ©ment <i>div</i> contenant les notes a un attribut [id](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). Le code JavaScript utilise l'identifiant pour trouver l'Ã©lÃ©ment.

L'onglet <i>Ã‰lÃ©ments</i> de la console peut Ãªtre utilisÃ© pour changer les styles des Ã©lÃ©ments.

![](../../images/0/18e.png)

Les modifications apportÃ©es sur la console ne seront pas permanentes. Si vous souhaitez apporter des modifications durables, elles doivent Ãªtre enregistrÃ©es dans la feuille de style CSS sur le serveur. 

### Chargement d'une page contenant JavaScript - rÃ©vision

Passons en revue ce qui se passe lorsque la page https://studies.cs.helsinki.fi/exampleapp/notes est ouverte sur le navigateur.

![](../../images/0/19e.png)

- Le navigateur va chercher le code HTML dÃ©finissant le contenu et la structure de la page sur le serveur Ã  l'aide d'une requÃªte HTTP GET.
- Les liens dans le code HTML amÃ¨nent le navigateur Ã  rÃ©cupÃ©rer Ã©galement la feuille de style CSS <i>main.css</i>...
- ...et un fichier de code JavaScript <i>main.js</i>
- Le navigateur exÃ©cute le code JavaScript. Le code fait une requÃªte HTTP GET Ã  l'adresse https://studies.cs.helsinki.fi/exampleapp/data.json, qui
   renvoie les notes sous forme de donnÃ©es JSON.
- Lorsque les donnÃ©es ont Ã©tÃ© rÃ©cupÃ©rÃ©es, le navigateur exÃ©cute un <i>gestionnaire d'Ã©vÃ©nements</i>, qui affiche les notes sur la page Ã  l'aide de l'API DOM. 

### Formulaires et HTTP POST

Examinons ensuite comment l'ajout d'une nouvelle note est effectuÃ©.

La page Notes contient un [form-element](https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Your_first_HTML_form).

![](../../images/0/20e.png)

Lorsque le bouton du formulaire est cliquÃ©, le navigateur enverra l'entrÃ©e de l'utilisateur au serveur. Ouvrons l'onglet <i>RÃ©seau</i> et voyons Ã  quoi ressemble l'envoi du formulaireÂ :

![Capture d'Ã©cran de l'onglet RÃ©seau oÃ¹ sont affichÃ©s les Ã©vÃ©nements de soumission du formulaire](../../images/0/21e.png)

Ã‰tonnamment, la soumission du formulaire provoque pas moins de <i>cinq</i>Â requÃªtes HTTP.
Le premier est l'Ã©vÃ©nement de soumission de formulaire. Zoomons dessus :

![Vue dÃ©taillÃ©e de la premiÃ¨re requÃªte](../../images/0/22e.png)

Il s'agit d'une requÃªte [HTTP POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) Ã  l'adresse du serveur <i>new\_note</i>. Le serveur rÃ©pond avec le code d'Ã©tat HTTP 302. Il s'agit d'une [URL redirect](https://en.wikipedia.org/wiki/URL_redirection), avec laquelle le serveur demande au navigateur de faire une nouvelle requÃªte HTTP GET Ã  l'adresse dÃ©finie dans <i>Emplacement</i> de l'en-tÃªte - l'adresse <i>notes</i>.

Ainsi, le navigateur recharge la page Notes. Le rechargement provoque trois requÃªtes HTTP supplÃ©mentairesÂ : la rÃ©cupÃ©ration de la feuille de style (main.css), du code JavaScript (main.js) et des donnÃ©es brutes des notes (data.json).

L'onglet rÃ©seau affiche Ã©galement les donnÃ©es soumises avec le formulaireÂ :

![](../../images/0/23e.png)

La balise Form a les attributs <i>action</i> et <i>method</i>, qui dÃ©finissent que la soumission du formulaire se fait sous la forme d'une requÃªte HTTP POST Ã  â€‹â€‹l'adresse <i>new_note</i>.

![](../../images/0/24e.png)

Le code sur le serveur responsable de la requÃªte POST est assez simple (NB : ce code est sur le serveur, et non sur le code JavaScript rÃ©cupÃ©rÃ© par le navigateur) :

```js
app.post('/new_note', (req, res) => {
  notes.push({
    content: req.body.note,
    date: new Date(),
  })

  return res.redirect('/notes')
})
```

Les donnÃ©es sont envoyÃ©es en tant que [corps](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) de la requÃªte POST.


Le serveur peut accÃ©der aux donnÃ©es en accÃ©dant au champ <em>req.body</em> de l'objet de requÃªte <em>req</em>.

Le serveur crÃ©e un nouvel objet note et l'ajoute Ã  un tableau appelÃ© <em>notes</em>.

```js
notes.push({
  content: req.body.note,
  date: new Date(),
})
```

Les objets Note ont deux champsÂ : <i>contenu</i> contenant le contenu rÃ©el de la note et <i>date</i> contenant la date et l'heure de crÃ©ation de la note.

Le serveur n'enregistre pas les nouvelles notes dans une base de donnÃ©es, de sorte que les nouvelles notes disparaissent lorsque le serveur est redÃ©marrÃ©.

### AJAX

La page Notes de l'application suit un style de dÃ©veloppement Web du dÃ©but des annÃ©es 90 et utilise "Ajax". En tant que tel, il est au sommet de la vague de la technologie Web du dÃ©but des annÃ©es 2000.

[AJAX](<https://en.wikipedia.org/wiki/Ajax_(programming)>) (JavaScript et XML asynchrones) est un terme introduit en fÃ©vrier 2005 suite aux progrÃ¨s de la technologie des navigateurs pour dÃ©crire une nouvelle approche rÃ©volutionnaire qui permettait de rÃ©cupÃ©rer du contenu sur des pages Web Ã  l'aide de JavaScript inclus dans le code HTML, sans qu'il soit nÃ©cessaire de restituer la page.

Avant l'Ã¨re AJAX, toutes les pages Web fonctionnaient comme les [applications Web traditionnelles](/en/part0/fundamentals_of_web_apps#traditional-web-applications) que nous avons vues prÃ©cÃ©demment dans ce chapitre.
Toutes les donnÃ©es affichÃ©es sur la page ont Ã©tÃ© rÃ©cupÃ©rÃ©es avec le code HTML gÃ©nÃ©rÃ© par le serveur.

La page Notes utilise AJAX pour rÃ©cupÃ©rer les donnÃ©es des notes. La soumission du formulaire utilise toujours le mÃ©canisme traditionnel de soumission de formulaires Web.

Les URL des applications reflÃ¨tent les temps anciens et insouciants. Les donnÃ©es JSON sont extraites de l'URL <https://studies.cs.helsinki.fi/exampleapp/data.json> et les nouvelles notes sont envoyÃ©es Ã  l'URL <https://studies.cs.helsinki.fi/exampleapp/new_note>.
De nos jours, de telles URL ne seraient pas considÃ©rÃ©es comme acceptables, car elles ne respectent pas les conventions gÃ©nÃ©ralement reconnues des API [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_Web_services), que nous examinerons plus en dÃ©tail dans la [partie 3](/en/part3)

La chose appelÃ©e AJAX est maintenant si banale qu'elle est prise pour acquise. Le terme est tombÃ© dans l'oubli, et la nouvelle gÃ©nÃ©ration n'en a mÃªme pas entendu parler.

### Application Ã  page unique

Dans notre exemple d'application, la page d'accueil fonctionne comme une page Web traditionnelleÂ : toute la logique se trouve sur le serveur et le navigateur affiche uniquement le code HTML conformÃ©ment aux instructions.

La page Notes donne une partie de la responsabilitÃ©, gÃ©nÃ©rant le code HTML pour les notes existantes, au navigateur. Le navigateur s'attaque Ã  cette tÃ¢che en exÃ©cutant le code JavaScript qu'il a rÃ©cupÃ©rÃ© sur le serveur. Le code rÃ©cupÃ¨re les notes du serveur sous forme de donnÃ©es JSON et ajoute des Ã©lÃ©ments HTML pour afficher les notes sur la page Ã  l'aide de [DOM-API](/en/part0/fundamentals_of_web_apps#document-object-model-or-dom).

Ces derniÃ¨res annÃ©es, le style [application Ã  page unique](https://en.wikipedia.org/wiki/Single-page_application) en anglais SPA (single page application) de crÃ©ation d'applications Web a Ã©mergÃ©. Les sites Web de style SPA ne rÃ©cupÃ¨rent pas toutes leurs pages sÃ©parÃ©ment du serveur comme le fait notre exemple d'application, mais ne comprennent qu'une seule page HTML extraite du serveur, dont le contenu est manipulÃ© avec JavaScript qui s'exÃ©cute dans le navigateur.

La page Notes de notre application ressemble un peu aux applications de style SPA, mais elle n'en est pas encore lÃ . MÃªme si la logique de rendu des notes est exÃ©cutÃ©e sur le navigateur, la page utilise toujours la mÃ©thode traditionnelle d'ajout de nouvelles notes. Les donnÃ©es sont envoyÃ©es au serveur avec la soumission du formulaire, et le serveur demande au navigateur de recharger la page Notes avec une <i>redirection</i>.

Une version SPA de notre exemple d'application peut Ãªtre trouvÃ©e sur <https://studies.cs.helsinki.fi/exampleapp/spa>.
Ã€ premiÃ¨re vue, l'application ressemble exactement Ã  la prÃ©cÃ©dente.
Le code HTML est presque identique, mais le fichier JavaScript est diffÃ©rent (<i>spa.js</i>) et il y a un petit changement dans la faÃ§on dont la balise form est dÃ©finieÂ :

![](../../images/0/25e.png)

Le formulaire n'a pas d'attributs <i>action</i> ou <i>method</i> pour dÃ©finir comment et oÃ¹ envoyer les donnÃ©es d'entrÃ©e.

Ouvrez l'onglet <i>RÃ©seau</i> et videz-le. Lorsque vous crÃ©ez maintenant une nouvelle note, vous remarquerez que le navigateur n'envoie qu'une seule requÃªte au serveur.

![](../../images/0/26e.png)

La requÃªte POST Ã  â€‹â€‹l'adresse <i>new\_note\_spa</i> contient la nouvelle note sous forme de donnÃ©es JSON contenant Ã  la fois le contenu de la note (<i>contenu</i>) et l'horodatage (<i> jour</i>)Â :

```js
{
  content: "single page app does not reload the whole page",
  date: "2019-05-25T15:15:59.905Z"
}
```

L'en-tÃªte <i>Content-Type</i> de la requÃªte indique au serveur que les donnÃ©es incluses sont reprÃ©sentÃ©es au format JSON.

![](../../images/0/27e.png)

Sans cet en-tÃªte, le serveur ne saurait pas analyser correctement les donnÃ©es.

Le serveur rÃ©pond avec le code d'Ã©tat [201 crÃ©Ã©](https://httpstatuses.com/201). Cette fois, le serveur ne demande pas de redirection, le navigateur reste sur la mÃªme page et n'envoie plus de requÃªtes HTTP.

La version SPA de l'application n'envoie pas les donnÃ©es de formulaire de maniÃ¨re traditionnelle, mais utilise Ã  la place le code JavaScript qu'elle a extrait du serveur.
Nous allons examiner un peu ce code, mÃªme si en comprendre tous les dÃ©tails n'est pas encore important.

```js
var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
```

La commande <em>document.getElementById('notes\_form')</em> indique au code de rÃ©cupÃ©rer l'Ã©lÃ©ment de formulaire Ã  partir de la page et d'enregistrer un <i>gestionnaire d'Ã©vÃ©nements</i> pour gÃ©rer l'Ã©vÃ¨nement de soumission du formulaire. Le gestionnaire d'Ã©vÃ©nements appelle immÃ©diatement la mÃ©thode <em>e.preventDefault()</em> pour empÃªcher la gestion par dÃ©faut de la soumission de formulaire. La mÃ©thode par dÃ©faut enverrait les donnÃ©es au serveur et provoquerait une nouvelle requÃªte GET, ce que nous ne voulons pas.


Ensuite, le gestionnaire d'Ã©vÃ©nements crÃ©e une nouvelle note, l'ajoute Ã  la liste des notes avec la commande <em>notes.push(note)</em>, restitue la liste des notes sur la page et envoie la nouvelle note au serveur.

Le code d'envoi de la note au serveur est le suivantÂ :

```js
var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader(
    'Content-type', 'application/json'
  )
  xhttpForPost.send(JSON.stringify(note))
}
```

Le code dÃ©termine que les donnÃ©es doivent Ãªtre envoyÃ©es avec une requÃªte HTTP POST et que le type de donnÃ©es doit Ãªtre JSON. Le type de donnÃ©es est dÃ©terminÃ© avec un en-tÃªte <i>Content-type</i>. Ensuite, les donnÃ©es sont envoyÃ©es sous forme de chaÃ®ne JSON.

Le code d'application est disponible sur <https://github.com/mluukkai/example_app>.
Il convient de rappeler que l'application est uniquement destinÃ©e Ã  dÃ©montrer les concepts du cours. Le code suit un style de dÃ©veloppement mÃ©diocre dans une certaine mesure et ne doit pas Ãªtre utilisÃ© comme exemple lors de la crÃ©ation de vos propres applications. Il en va de mÃªme pour les URL utilisÃ©es. L'URL <i>new\_note\_spa</i>, Ã  laquelle les nouvelles notes sont envoyÃ©es, ne respecte pas les meilleures pratiques actuelles.

### BibliothÃ¨ques JavaScript

L'exemple d'application est rÃ©alisÃ© avec ce qu'on appelle [vanilla JavaScript](https://www.freecodecamp.org/news/is-vanilla-javascript-worth-learning-absolutely-c2c67140ac34/), en utilisant uniquement l'API DOM et JavaScript pour manipuler la structure des pages.

Au lieu d'utiliser uniquement JavaScript et l'API DOM, diffÃ©rentes bibliothÃ¨ques contenant des outils plus faciles Ã  utiliser par rapport Ã  l'API DOM sont souvent utilisÃ©es pour manipuler les pages. L'une de ces bibliothÃ¨ques est la trÃ¨s populaire [jQuery](https://jquery.com/).

jQuery a Ã©tÃ© dÃ©veloppÃ© Ã  l'Ã©poque oÃ¹ les applications Web suivaient principalement le style traditionnel du serveur gÃ©nÃ©rant des pages HTML, dont la fonctionnalitÃ© Ã©tait amÃ©liorÃ©e du cÃ´tÃ© du navigateur Ã  l'aide de JavaScript Ã©crit avec jQuery. L'une des raisons du succÃ¨s de jQuery Ã©tait sa soi-disant compatibilitÃ© entre navigateurs. La bibliothÃ¨que fonctionnait quel que soit le navigateur ou la sociÃ©tÃ© qui l'avait crÃ©Ã©e, il n'y avait donc pas besoin de solutions spÃ©cifiques au navigateur. De nos jours, l'utilisation de jQuery n'est plus aussi justifiÃ©e compte tenu de l'avancement de JavaScript, et les navigateurs les plus populaires supportent gÃ©nÃ©ralement bien les fonctionnalitÃ©s de base.

L'essor de l'application Ã  page unique a apportÃ© plusieurs mÃ©thodes de dÃ©veloppement Web plus "modernes" que jQuery. Le favori de la premiÃ¨re vague de dÃ©veloppeurs Ã©tait [BackboneJS](http://backbonejs.org/). AprÃ¨s son [lancement](https://github.com/angular/angular.js/blob/master/CHANGELOG.md#100-temporal-domination-2012-06-13) en 2012, Google [AngularJS](https: //angularjs.org/) est rapidement devenu presque la norme de facto du dÃ©veloppement Web moderne.

Cependant, la popularitÃ© d'Angular a chutÃ© en octobre 2014 aprÃ¨s que [l'Ã©quipe d'Angular a annoncÃ© que le support de la version 1 prendra fin](https://jaxenter.com/angular-2-0-announcement-backfires-112127.html), et Angular 2 ne sera pas rÃ©trocompatible avec la premiÃ¨re version. Angular 2 et les versions plus rÃ©centes n'ont pas Ã©tÃ© trop chaleureusement accueillies.

Actuellement, l'outil le plus populaire pour implÃ©menter la logique cÃ´tÃ© navigateur des applications Web est la bibliothÃ¨que [React](https://reactjs.org/) de Facebook.
Au cours de ce cours, nous nous familiariserons avec React et la bibliothÃ¨que [Redux](https://github.com/reactjs/redux), qui sont frÃ©quemment utilisÃ©es ensemble.

Le statut de React semble fort, mais le monde de JavaScript est en constante Ã©volution. Par exemple, rÃ©cemment, un nouveau venu - [VueJS](https://vuejs.org/) - a suscitÃ© un certain intÃ©rÃªt.

###Â DÃ©veloppement Web Full Stack

Que signifie le nom du cours, <i>DÃ©veloppement Web Full Stack</i>Â ? Le full stack est un mot Ã  la mode dont tout le monde parle, alors que personne ne sait vraiment ce que cela signifie. Ou du moins, il n'y a pas de dÃ©finition convenue pour le terme.

Pratiquement toutes les applications Web ont (au moins) deux "couches": le navigateur, Ã©tant plus proche de l'utilisateur final, est la couche supÃ©rieure et le serveur la couche infÃ©rieure. Il y a souvent aussi une couche de base de donnÃ©es sous le serveur. On peut donc penser Ã  l'<i>architecture</i> d'une application web comme une sorte de <i>pile</i> de couches.

Souvent, on parle aussi du [frontend et du backend](https://en.wikipedia.org/wiki/Front_and_back_ends). Le navigateur est l'interface, et JavaScript qui s'exÃ©cute sur le navigateur est le code de l'interface. Le serveur, quant Ã  lui, est le backend.

Dans le cadre de ce cours, le dÃ©veloppement web full stack signifie que nous nous concentrons sur toutes les parties de l'application : le frontend, le backend et la base de donnÃ©es. Parfois, le logiciel sur le serveur et son systÃ¨me d'exploitation sont considÃ©rÃ©s comme faisant partie de la pile, mais nous n'entrerons pas dans ceux-ci.

Nous allons coder le backend avec JavaScript, en utilisant l'environnement d'exÃ©cution [Node.js](https://nodejs.org/en/). L'utilisation du mÃªme langage de programmation sur plusieurs couches de la pile donne au dÃ©veloppement Web de la pile complÃ¨te une toute nouvelle dimension. Cependant, il n'est pas obligatoire pour le dÃ©veloppement Web de la pile complÃ¨te d'utiliser le mÃªme langage de programmation (JavaScript) pour toutes les couches de la pile.

Auparavant, il Ã©tait plus courant pour les dÃ©veloppeurs de se spÃ©cialiser dans une couche de la pile, par exemple le backend. Les technologies sur le backend et le frontend Ã©taient assez diffÃ©rentes. Avec la tendance Full stack, il est devenu courant pour les dÃ©veloppeurs de maÃ®triser toutes les couches de l'application et de la base de donnÃ©es. Souvent, les dÃ©veloppeurs full stack doivent Ã©galement avoir suffisamment de compÃ©tences en configuration et en administration pour faire fonctionner leur application, par exemple dans le cloud.

### Fatigue JavaScript

Le dÃ©veloppement Web complet est un dÃ©fi Ã  bien des Ã©gards. Les choses se passent dans de nombreux endroits Ã  la fois, et le dÃ©bogage est un peu plus difficile qu'avec les applications de bureau classiques. JavaScript ne fonctionne pas toujours comme prÃ©vu (par rapport Ã  de nombreux autres langages), et le fonctionnement asynchrone de ses environnements d'exÃ©cution entraÃ®ne toutes sortes de dÃ©fis. Communiquer sur le web nÃ©cessite la connaissance du protocole HTTP. Il faut Ã©galement gÃ©rer les bases de donnÃ©es et l'administration et la configuration des serveurs. Il serait Ã©galement bon de connaÃ®tre suffisamment de CSS pour rendre les applications au moins quelque peu prÃ©sentables.

Le monde de JavaScript se dÃ©veloppe rapidement, ce qui apporte son lot de dÃ©fis. Les outils, les bibliothÃ¨ques et le langage lui-mÃªme sont en constante Ã©volution. Certains commencent Ã  en avoir assez du changement constant et ont inventÃ© un terme pour celaÂ : <em>fatigue JavaScript</em>. Voir [How to Manage JavaScript Fatigue on auth0](https://auth0.com/blog/how-to-manage-javascript-fatigue/) ou [JavaScript fatigue on Medium](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4).

Vous souffrirez vous-mÃªme de la fatigue JavaScript pendant ce cours. Heureusement pour nous, il existe plusieurs faÃ§ons de lisser la courbe d'apprentissage, et nous pouvons commencer par le codage au lieu de la configuration. Nous ne pouvons pas complÃ¨tement Ã©viter la configuration, mais nous pouvons joyeusement aller de l'avant dans les prochaines semaines tout en Ã©vitant le pire des enfers de configuration. 

</div>

<div class="tasks"> 
  <h3>Exercices 0.1.-0.6.</h3>

Les exercices sont soumis via GitHub, et en marquant les exercices comme effectuÃ©s dans le [systÃ¨me de soumission](https://studies.cs.helsinki.fi/stats/courses/fullstackopen).

Vous pouvez soumettre tous les exercices dans le mÃªme rÃ©fÃ©rentiel ou utiliser plusieurs rÃ©fÃ©rentiels diffÃ©rents. Si vous soumettez des exercices de diffÃ©rentes parties dans le mÃªme rÃ©fÃ©rentiel, nommez bien vos rÃ©pertoires. Si vous utilisez un rÃ©fÃ©rentiel privÃ© pour soumettre les exercices, ajoutez-y _mluukkai_ en tant que collaborateur.

Une bonne faÃ§on de nommer les rÃ©pertoires de votre rÃ©fÃ©rentiel de soumission est la suivanteÂ :

```
part0
part1
  courseinfo
  unicafe
  anecdotes
part2
  courseinfo
  phonebook
  countries
```

Ainsi, chaque partie a son propre rÃ©pertoire, qui contient un rÃ©pertoire pour chaque ensemble d'exercices (comme les exercices unicafÃ© de la partie 1).

Les exercices sont soumis **une partie Ã  la fois**. Lorsque vous avez soumis les exercices d'une partie, vous ne pouvez plus soumettre d'exercices manquÃ©s pour cette partie.

  <h4>0.1: HTML</h4>

Passez en revue les bases du HTML en lisant ce didacticiel de MozillaÂ : [tutoriel HTML](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics).

<i>Cet exercice n'est pas soumis Ã  GitHub, il suffit de lire le tutoriel</i>

  <h4>0.2: CSS</h4>

Passez en revue les bases de CSS en lisant ce tutoriel de MozillaÂ : [tutoriel CSS](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics).

<i>Cet exercice n'est pas soumis Ã  GitHub, il suffit de lire le tutoriel</i>

   <h4>0.3Â : Formulaires HTML</h4>

DÃ©couvrez les bases des formulaires HTML en lisant le didacticiel de Mozilla [Votre premier formulaire](https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Your_first_HTML_form).

<i>Cet exercice n'est pas soumis Ã  GitHub, il suffit de lire le tutoriel</i>

  <h4>0.4Â : Nouvelle note</h4>

Dans le chapitre [Chargement d'une page contenant JavaScript - rÃ©vision](/fr/part0/introduction_aux_applications_web#chargement-dune-page-contenant-java-script-revision) la chaÃ®ne d'Ã©vÃ©nements causÃ©s par l'ouverture de la page https://studies.cs.helsinki.fi/exampleapp/notes est reprÃ©sentÃ©e comme un [diagramme de sÃ©quence](https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/)

Le diagramme a Ã©tÃ© crÃ©Ã© Ã  l'aide du service [websequencediagrams](https://www.websequencediagrams.com) comme suitÂ :

```
browser->server: HTTP GET https://studies.cs.helsinki.fi/exampleapp/notes
server-->browser: HTML-code
browser->server: HTTP GET https://studies.cs.helsinki.fi/exampleapp/main.css
server-->browser: main.css
browser->server: HTTP GET https://studies.cs.helsinki.fi/exampleapp/main.js
server-->browser: main.js

note over browser:
browser starts executing js-code
that requests JSON data from server 
end note

browser->server: HTTP GET https://studies.cs.helsinki.fi/exampleapp/data.json
server-->browser: [{ content: "HTML is easy", date: "2019-05-23" }, ...]

note over browser:
browser executes the event handler
that renders notes to display
end note
```

**CrÃ©ez un diagramme similaire** illustrant la situation oÃ¹ l'utilisateur crÃ©e une nouvelle note sur la page <https://studies.cs.helsinki.fi/exampleapp/notes> en Ã©crivant quelque chose dans le champ de texte et en cliquant sur le <i> bouton envoyer</i>.

Si nÃ©cessaire, affichez les opÃ©rations sur le navigateur ou sur le serveur sous forme de commentaires sur le diagramme.

Le diagramme ne doit pas nÃ©cessairement Ãªtre un diagramme de sÃ©quence. Toute maniÃ¨re sensÃ©e de prÃ©senter les Ã©vÃ©nements est acceptable.

Toutes les informations nÃ©cessaires pour ce faire, ainsi que les deux exercices suivants, se trouvent dans le texte de [cette partie](/fr/part0/introduction_aux_applications_web#formulaires-et-http-post).
L'idÃ©e de ces exercices est de lire le texte une fois de plus et de rÃ©flÃ©chir Ã  ce qui s'y passe. La lecture de l'application [code](https://github.com/mluukkai/example_app) n'est pas nÃ©cessaire, mais c'est bien sÃ»r possible.

  <h4>0.5Â :Â Application Ã  page unique</h4>

CrÃ©ez un diagramme illustrant la situation dans laquelle l'utilisateur accÃ¨de Ã  la version [application Ã  page unique](/fr/part0/introduction_aux_applications_web#application-a-page-unique) de l'application de notes sur <https://studies.cs.helsinki.fi/exempleapp/spa>.

  <h4>0.6Â : Nouvelle note</h4>

CrÃ©ez un diagramme illustrant la situation dans laquelle l'utilisateur crÃ©e une nouvelle note Ã  l'aide de la version Ã  page unique de l'application.

C'Ã©tait le dernier exercice, et il est temps de transmettre vos rÃ©ponses Ã  GitHub et de marquer les exercices comme effectuÃ©s dans le [systÃ¨me de soumission](https://studies.cs.helsinki.fi/stats/courses/fullstackopen).
</div>
